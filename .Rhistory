library(usethis)
use_author(given = "YiMing" ,family = "Yan",email="yanyiming.shiqing@hrbmu.edu.cn",role = c("cre","aut"))
use_author(given = "Peng" ,family = "Xiao",email="2025020433@hrbmu.edu.cn",role = "aut")
use_mit_license("YiMing Yan")
message("ROGUE开始\n")
roxygenize(package.dir = ".")
roxygen2::roxygenize(package.dir = ".")
roxygen2::roxygenize(package.dir = ".")
roxygen2::roxygenize(package.dir = ".")
?JoinLayers
roxygen2::roxygenize(package.dir = ".")
tools::showNonASCIIfile()
tools::showNonASCIIfile("EVAcluster.R")
tools::showNonASCIIfile("EVAcluster.Rproj")
x=tools::showNonASCIIfile("EVAcluster.Rproj")
remove(x)
x=tools::showNonASCIIfile("R/EVAcluster.R")
tools::showNonASCIIfile("R/EVAcluster.R")
tools::showNonASCIIfile("R/EVAcluster.R")
devtools::build()
devtools::install()
devtools::build()
devtools::install()
devtools::build()
devtools::install()
?abline
tools::showNonASCIIfile("R/EVAcluster.R")
devtools::build_vignettes()
devtools::build_manual(pkg = ".", path = './doc')
devtools::check_man()
install.packages("tinytex")
install.packages("tinytex")
tinytex::install_tinytex()
devtools::build_manual(pkg = ".", path = './doc')
devtools::build(vignettes = TRUE, manual = TRUE)
usethis::use_vignette("my-vignette")
devtools::build_vignettes()
devtools::build_manual(pkg = ".", path = './doc')
rlang::last_trace()
tinytex::pdflatex_available()
tinytex::is_tinytex()
devtools::build()
devtools::build()
devtools::build()
?stability_plot
?GetAssayData
devtools::build()
devtools::build_vignettes()
devtools::build_manual(pkg = ".", path = './doc')
devtools::build(vignettes = TRUE)
devtools::build(vignettes = T)
devtools::build(vignettes = T)
data=readRDS("E:/数据/聚类评价/TNK_15.RDS")
cores = 1
auc_logfc = 0.25
auc_min_pct = 0.5
auc_cutoff = 0.6
rogue_threshold = 0.8
# data: Seurat object
# cores: number of cores to use for parallel parts. For Windows AUC uses makeCluster; for ROGUE we use mclapply if cores>1 (linux)
# auc_logfc / auc_min_pct / auc_cutoff: parameters for FindAllMarkers (MGA)
# rogue_threshold: threshold (0.8) to determine minimal resolution
set.seed(12315)
# ---- checks ----
if (!inherits(data, "Seurat")) stop("`data` must be a Seurat object.")
required_pkgs <- c("Seurat", "parallel", "dplyr", "clusterCrit", "cluster")
missing_pkgs <- required_pkgs[!sapply(required_pkgs, requireNamespace, quietly = TRUE)]
if (length(missing_pkgs)) stop(paste0("Please install required packages: ", paste(missing_pkgs, collapse = ", ")))
# optional heavier packages
if (!requireNamespace("ROGUE", quietly = TRUE)) stop("ROGUE is required. Please install it from GitHub.")
if (!requireNamespace("lisi", quietly = TRUE)) stop("lisi is required. Please install it.")
if (!requireNamespace("mrtree", quietly = TRUE)) stop("mrtree is required. Please install it.")
library(Seurat)
library(dplyr)
library(parallel)
library(clusterCrit)
library(cluster)
# ---- prepare ----
data <- JoinLayers(data)  # 保持原逻辑
data_ori <- as.data.frame(data@reductions$umap@cell.embeddings)
meta_ori <- data@meta.data
res_cols <- grep("^RNA_snn_res\\.", colnames(meta_ori), value = TRUE)
if (length(res_cols) == 0) stop("No resolution columns found matching ^RNA_snn_res\\.")
# ensure resolutions are sorted numerically by the suffix
res_vals <- as.numeric(sub("RNA_snn_res\\.", "", res_cols))
ord <- order(res_vals)
res_cols <- res_cols[ord]
res_vals <- res_vals[ord]
names(res_cols) <- res_cols
# 保存每个分辨率下的簇 label （factor）
cluster_labels <- lapply(res_cols, function(rc) {
as.character(meta_ori[[rc]])
})
names(cluster_labels) <- res_cols
# ---- ROGUE (并行形式尽量保持) ----
message("ROGUE start")
expr <- GetAssayData(data, assay = "RNA", layer = "counts")
gc()
gc()
x=readRDS("H:/x.rds")
View(x)
data=readRDS("E:/数据/聚类评价/TNK_15.RDS")
View(x)
s=x$score_table
View(s)
View(s)
ss=x$scaled_score_table
View(ss)
cores = 1
set.seed(12315)
data <- JoinLayers(data)  # 保持原逻辑
data_ori <- as.data.frame(data@reductions$umap@cell.embeddings)
meta_ori <- data@meta.data
res_cols <- grep("^RNA_snn_res\\.", colnames(meta_ori), value = TRUE)
if (length(res_cols) == 0) stop("No resolution columns found matching ^RNA_snn_res\\.")
# ensure resolutions are sorted numerically by the suffix
res_vals <- as.numeric(sub("RNA_snn_res\\.", "", res_cols))
ord <- order(res_vals)
res_cols <- res_cols[ord]
res_vals <- res_vals[ord]
names(res_cols) <- res_cols
# 保存每个分辨率下的簇 label （factor）
cluster_labels <- lapply(res_cols, function(rc) {
as.character(meta_ori[[rc]])
})
names(cluster_labels) <- res_cols
library(Seurat)
library(dplyr)
library(parallel)
library(clusterCrit)
library(cluster)
library(ROGUE)
library(lisi)
library(mrtree)
message("LISI start")
# We'll compute LISI with meta columns: 'orig.ident' as batch (for bLISI),
# and for cLISI we compute per-resolution label LISI (we will compute mean LISI per resolution and invert so larger is better)
# compute with lisi::compute_lisi: pass metadata columns c("orig.ident", res_cols...)
lisi_meta_cols <- c("orig.ident", res_cols)
# ensure these columns exist
lisi_meta_cols <- lisi_meta_cols[lisi_meta_cols %in% colnames(meta_ori)]
# compute_lisi expects metadata columns names to be provided as character vector
lisi_mat <- lisi::compute_lisi(data_ori, meta_ori, lisi_meta_cols)
# lisi_mat: rows=cells, cols=each metadata var
# bLISI: mean per resolution across cells for orig.ident -> smaller means better mixing? earlier you used 1/mean to invert
if ("orig.ident" %in% colnames(lisi_mat)) {
blisi_val <- mean(lisi_mat[ , "orig.ident"], na.rm = TRUE)
blisi_score_single <- 1/blisi_val
} else {
blisi_score_single <- NA_real_
}
# for cluster-wise LISI: for each resolution column, take mean LISI and invert (so larger = better)
clisi_scores <- c()
for (rc in res_cols) {
if (rc %in% colnames(lisi_mat)) {
v <- mean(lisi_mat[, rc], na.rm = TRUE)
clisi_scores[rc] <- 1/v
} else {
clisi_scores[rc] <- NA_real_
}
}
names(clisi_scores) <- sub("RNA_snn_res\\.", "", names(clisi_scores))
blisi_vec <- rep(blisi_score_single, length(clisi_scores))
names(blisi_vec) <- names(clisi_scores)
message("LISI finish")
View(lisi_mat)
View(lisi_mat)
View(lisi_mat)
?compute_lisi
View(lisi_mat)
View(lisi_mat)
View(lisi_mat)
View(data_ori)
batch1 <- lisi::compute_lisi(data_ori, c(meta_ori$orig.ident,meta_ori$RNA_snn_res.0.1), c("batch","0,1"))
batch1 <- lisi::compute_lisi(data_ori, c(meta_ori$orig.ident,meta_ori$'RNA_snn_res.0.1'), c("batch","0,1"))
batch1 <- lisi::compute_lisi(data_ori, meta_ori[,c("orig.ident","RNA_snn_res.0.1")], c("batch","0,1"))
batch1 <- lisi::compute_lisi(data_ori, meta_ori[,c("orig.ident","RNA_snn_res.0.1")], c("batch","0,1"))
meta_ori[,c("orig.ident","RNA_snn_res.0.1")]
View(data)
as.factor(meta_ori$orig.ident)
meta_ori[,c("orig.ident","RNA_snn_res.0.1")]
batch1 <- lisi::compute_lisi(data_ori, meta_ori[,c("orig.ident","RNA_snn_res.0.1")], c("batch","0.1"))
batch1 <- lisi::compute_lisi(data_ori, meta_ori[,c("orig.ident","RNA_snn_res.0.1")], c("orig.ident","RNA_snn_res.0.1"))
View(batch1)
batch2 <- lisi::compute_lisi(data_ori, meta_ori[,c("orig.ident","RNA_snn_res.0.2")], c("orig.ident","RNA_snn_res.0.2"))
View(batch1)
View(batch2)
median(lisi_mat$orig.ident)
View(lisi_mat)
View(cluster_labels)
View(batch2)
View(lisi_mat)
clisi_scores
# for cluster-wise LISI: for each resolution column, take mean LISI and invert (so larger = better)
clisi_scores <- c()
for (rc in res_cols) {
if (rc %in% colnames(lisi_mat)) {
v <- mean(lisi_mat[, rc], na.rm = TRUE)
clisi_scores[rc] <- v
} else {
clisi_scores[rc] <- NA_real_
}
}
clisi_scores
View(ss)
View(s)
View(lisi_mat)
clisi_scores[rc] <- 1/v
# for cluster-wise LISI: for each resolution column, take mean LISI and invert (so larger = better)
clisi_scores <- c()
for (rc in res_cols) {
if (rc %in% colnames(lisi_mat)) {
v <- mean(lisi_mat[, rc], na.rm = TRUE)
clisi_scores[rc] <- 1/v
} else {
clisi_scores[rc] <- NA_real_
}
}
clisi_scores
View(meta_ori)
View(s)
View(s)
data=readRDS("E:/数据/聚类评价/TNK_15.RDS")
message("devtools::install_github(\"PaulingLiu/ROGUE\")")
message("use devtools::install_github(\"immunogenomics/lisi\") to install")
message("Package 'ROGUE' not found. You can install it with:")
message("Package 'ROGUE' not found. You can install it with:")
message("  devtools::install_github('PaulingLiu/ROGUE')")
stop("Please install the ROGUE package before running EvaluateCluster().")
remove.packages("EVAcluster")
devtools::document()
devtools::document()
devtools::document()
devtools::build()
devtools::build()
devtools::document()
devtools::build()
remove.packages("EvaluateCluster")
devtools::install_github("ml-analyst-yym/EvaluateCluster")
devtools::document()
devtools::build()
table(meta_ori[[label[8]]])
